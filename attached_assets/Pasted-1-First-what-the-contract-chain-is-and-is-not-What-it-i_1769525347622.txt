1Ô∏è‚É£ First: what the contract chain is (and is not)
What it is

A contract chain is an ordered execution plan that describes how to fulfill a request within a single intent and scope.

Think of it as:

‚ÄúGiven what the user wants, what steps must happen, and in what order, to produce the correct output?‚Äù

Each contract:

performs one task

has a fixed output shape

has explicit authority rules

may depend on outputs of earlier contracts

What it is not

It is not one contract per question

It is not one contract per sentence

It is not dynamic improvisation by the LLM

It is not intent switching

The contract chain is planned, not discovered mid-flight.

2Ô∏è‚É£ Who decides the contract chain?

Not the LLM. Ever.

The contract chain is decided by the control plane, using:

The resolved intent

The resolved scope

The inferred task(s) required to answer

The LLM‚Äôs role starts after the chain is fixed.

If the LLM were allowed to decide contracts, you‚Äôd lose determinism, auditability, and safety.

So:

Control Plane = planner

LLM = executor

3Ô∏è‚É£ How the system decides which contracts are needed

This is the key mental model:

Contracts are selected based on the minimum set of tasks required to satisfy the user‚Äôs request.

Not based on:

wording

number of sentences

number of questions embedded

The system asks (implicitly):

What kind of work must be done?

extraction?

synthesis?

explanation?

drafting?

Does any task depend on another?

you can‚Äôt answer questions before extracting them

you can‚Äôt compare before collecting data

What authority level is required?

extractive only?

descriptive?

authoritative?

The answers to those questions determine the chain.

4Ô∏è‚É£ The fundamental restriction rules (these are important)

There are strict restrictions. This is what keeps the system sane.

üîí Restriction 1: Contracts must share the same intent

All contracts in a chain must be valid under the same intent and scope.

‚úÖ Allowed:

SINGLE_MEETING ‚Üí CUSTOMER_QUESTIONS ‚Üí DRAFT_RESPONSE

MULTI_MEETING ‚Üí CROSS_MEETING_QUESTIONS ‚Üí PATTERN_ANALYSIS

‚ùå Not allowed:

SINGLE_MEETING ‚Üí FEATURE_VERIFICATION

MULTI_MEETING ‚Üí PRODUCT_EXPLANATION
(these change scope)

If a request would require contracts from different intents:
‚Üí CLARIFY and ask the user to split.

üîí Restriction 2: Contracts must be orderable

Contracts must form a logical sequence.

Examples:

Extraction ‚Üí analysis ‚Üí drafting (valid)

Drafting ‚Üí extraction (invalid)

Authoritative verification before data exists (invalid)

This sounds obvious, but enforcing it prevents subtle bugs.

üîí Restriction 3: Authority must not escalate accidentally

Authority may:

stay the same

become more restrictive

It must never silently escalate.

Examples:

Extractive ‚Üí Descriptive (OK)

Descriptive ‚Üí Authoritative (ONLY if explicitly required)

Extractive ‚Üí Authoritative (usually wrong)

This is why SSOT mode is attached to each contract.

üîí Restriction 4: Contracts must be task-shaped, not topic-shaped

You already stated this correctly:

Contracts are shaped by task and output, not by question or topic.

So:

PATTERN_ANALYSIS ‚úÖ

DASHBOARD_ISSUES_ANALYSIS ‚ùå

Topics belong in scope filters, not contracts.

5Ô∏è‚É£ How many contracts can be in a chain?

There‚Äôs no hard number, but there is a soft rule:

If a chain feels long or spans different scopes, you‚Äôre probably violating the Single Intent invariant.

In practice:

1‚Äì2 contracts: very common

3 contracts: acceptable for compound tasks

4+: rare and usually a smell

Example of a good 2-contract chain:

CUSTOMER_QUESTIONS
‚Üí DRAFT_RESPONSE


Example of a good 3-contract chain:

CROSS_MEETING_QUESTIONS
‚Üí PATTERN_ANALYSIS
‚Üí DRAFT_SUMMARY

6Ô∏è‚É£ Concrete examples (this usually makes it click)
Example 1 ‚Äî Single meeting, compound task

User

‚ÄúHelp me answer the questions from the ACE meeting.‚Äù

Intent: SINGLE_MEETING
Scope: ACE meeting

Required tasks:

Extract questions

Draft responses

Contract chain:

CUSTOMER_QUESTIONS
‚Üí DRAFT_RESPONSE

Example 2 ‚Äî Multi-meeting analysis

User

‚ÄúWhat common objections are customers raising about dashboards?‚Äù

Intent: MULTI_MEETING
Scope: all relevant meetings

Required tasks:

Collect questions across meetings

Identify recurring themes

Contract chain:

CROSS_MEETING_QUESTIONS
‚Üí PATTERN_ANALYSIS

Example 3 ‚Äî Single contract is enough

User

‚ÄúSummarize the last ACE meeting.‚Äù

Intent: SINGLE_MEETING
Scope: ACE meeting

Required task:

summarization only

Contract chain:

MEETING_SUMMARY

Example 4 ‚Äî Invalid (must CLARIFY)

User

‚ÄúSummarize the meeting and tell me if PitCrew supports POS integration.‚Äù

This requires:

SINGLE_MEETING

PRODUCT_KNOWLEDGE

Two intents ‚Üí two scopes ‚Üí incompatible contracts.

Correct behavior:
‚Üí CLARIFY and ask the user to split.

7Ô∏è‚É£ Why this model scales cleanly

This design works long-term because:

New contracts add new capabilities without changing intent logic

New intents add new scopes without breaking existing contracts

Authority is always explicit

Debugging is trivial (‚Äúwhich contract did the wrong thing?‚Äù)

This is exactly the kind of deep module Ousterhout talks about.

One-sentence summary you can reuse

The control plane selects the smallest ordered set of task-based contracts needed to satisfy a single intent and scope, enforcing ordering and authority rules so execution remains safe and deterministic.