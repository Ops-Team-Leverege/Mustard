import { MODEL_ASSIGNMENTS } from "../config/models";

/**
 * Source Attribution Configuration
 * 
 * Controls which response types show source attribution.
 * Set any category to `false` to disable its attribution line.
 * This allows quick toggling based on user/team feedback.
 */
export const SOURCE_ATTRIBUTION_CONFIG = {
  transcripts_semantic: true,
  transcripts_artifacts: true,
  product_database: true,
  external_research: true,
  slack_context: true,
  general_knowledge: true,
} as const;

type SourceAttributionContext = {
  dataSource: string | null;
  semanticAnswerUsed?: boolean;
  semanticConfidence?: string;
  intent?: string | null;
  answerContract?: string | null;
  usedSingleMeetingMode?: boolean;
  isClarificationRequest?: boolean;
  responseText?: string;
};

const FRIENDLY_MODEL_NAMES: Record<string, string> = {
  "gpt-4o-mini": "GPT-4o Mini",
  "gpt-4o": "GPT-4o",
  "gpt-5": "GPT-5",
  "gemini-2.5-flash": "Gemini 2.5 Flash",
};

function friendlyModelName(model: string): string {
  return FRIENDLY_MODEL_NAMES[model] || model;
}

const NEGATIVE_ANSWER_PATTERNS = [
  /no information/i,
  /no data/i,
  /not mentioned/i,
  /not discussed/i,
  /no mention/i,
  /couldn't find/i,
  /could not find/i,
  /I'm sorry, but there is no/i,
  /does not contain/i,
  /do not mention/i,
  /no relevant/i,
];

function isNegativeAnswer(responseText?: string, confidence?: string): boolean {
  if (confidence === "low") return true;
  if (!responseText) return false;
  return NEGATIVE_ANSWER_PATTERNS.some(pattern => pattern.test(responseText));
}

export function getSourceAttribution(ctx: SourceAttributionContext): string {
  const { dataSource, semanticAnswerUsed, semanticConfidence, intent, usedSingleMeetingMode, isClarificationRequest, responseText } = ctx;

  if (isClarificationRequest || dataSource === "none" || dataSource === "clarification" || dataSource === "not_found") {
    return "";
  }

  if ((dataSource === "semantic" || semanticAnswerUsed) && SOURCE_ATTRIBUTION_CONFIG.transcripts_semantic) {
    if (isNegativeAnswer(responseText, semanticConfidence)) {
      return "";
    }
    const model = friendlyModelName(MODEL_ASSIGNMENTS.SEMANTIC_ANSWER_SYNTHESIS);
    return `\n\n_Source: PitCrew Meeting Transcripts (synthesized by ${model})_`;
  }

  const transcriptSources = ["transcript", "summary", "binary_answer", "customer_questions", "action_items", "attendees", "meeting_artifacts"];
  if (dataSource && transcriptSources.includes(dataSource) && SOURCE_ATTRIBUTION_CONFIG.transcripts_artifacts) {
    return `\n\n_Source: PitCrew Meeting Transcripts_`;
  }

  if (dataSource === "product_ssot" && SOURCE_ATTRIBUTION_CONFIG.product_database) {
    return `\n\n_Source: PitCrew Product Database_`;
  }

  if (dataSource === "external_research" && SOURCE_ATTRIBUTION_CONFIG.external_research) {
    const model = friendlyModelName(MODEL_ASSIGNMENTS.EXTERNAL_RESEARCH_WEB);
    return `\n\n_Source: Web Research (via ${model})_`;
  }

  if (dataSource === "slack" && SOURCE_ATTRIBUTION_CONFIG.slack_context) {
    return `\n\n_Source: Slack Thread Context_`;
  }

  if (dataSource === "general_knowledge" && SOURCE_ATTRIBUTION_CONFIG.general_knowledge) {
    const model = usedSingleMeetingMode
      ? friendlyModelName(MODEL_ASSIGNMENTS.SINGLE_MEETING_RESPONSE)
      : friendlyModelName(MODEL_ASSIGNMENTS.GENERAL_ASSISTANCE);
    return `\n\n_Source: Generated by ${model}_`;
  }

  if ((intent === "GENERAL_HELP" || intent === "REFUSE" || intent === "GREETING") && SOURCE_ATTRIBUTION_CONFIG.general_knowledge) {
    const model = friendlyModelName(MODEL_ASSIGNMENTS.GENERAL_ASSISTANCE);
    return `\n\n_Source: Generated by ${model}_`;
  }

  return "";
}
